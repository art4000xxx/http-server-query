HTTP-сервер с поддержкой Query и форм данных
Этот проект представляет собой HTTP-сервер, реализованный на Java в рамках домашнего задания курса Netology по теме «1.2. Формы и форматы передачи данных». Сервер расширяет функциональность предыдущего задания, добавляя поддержку обработки параметров Query String, форм в формате x-www-form-urlencoded и запросов multipart/form-data.
Возможности

Многопоточность: Обработка входящих соединений осуществляется с помощью пула потоков (ExecutorService с 64 потоками).
Кастомные обработчики: Поддержка динамической регистрации обработчиков для методов HTTP (GET, POST) и путей.
Парсинг Query String: Извлечение параметров из строки запроса с использованием URLEncodedUtils из Apache HttpClient.
Поддержка x-www-form-urlencoded: Обработка данных форм, переданных в теле POST-запросов с типом application/x-www-form-urlencoded.
Поддержка multipart/form-data: Обработка загрузки файлов и полей форм с использованием Apache Commons FileUpload.
Обработка ошибок: Возврат соответствующих кодов состояния HTTP (400, 404, 500) для некорректных запросов.
Логирование: Использование SLF4J для детального логирования запросов и ошибок.

Структура проекта
http-server-query/
├── src/
│   └── main/
│       └── java/
│           └── ru/
│               └── netology/
│                   └── server/
│                       ├── ByteArrayRequestContext.java  # Вспомогательный класс для парсинга multipart
│                       ├── Handler.java                # Функциональный интерфейс для обработчиков
│                       ├── Request.java               # Класс запроса с поддержкой query/form/multipart
│                       ├── Server.java               # Основная логика сервера
│                       ├── Main.java                 # Точка входа приложения
├── pom.xml                                          # Конфигурация Maven
├── README.md                                       # Документация проекта

Архитектурные решения
1. Пул потоков для многопоточности

Почему: Использование фиксированного пула потоков (ExecutorService с 64 потоками) позволяет эффективно обрабатывать множество клиентских соединений, не создавая новый поток для каждого запроса. Это снижает нагрузку на систему и предотвращает исчерпание ресурсов. Число 64 выбрано как оптимальное для учебного проекта.
Альтернативы: Динамический пул (CachedThreadPool) мог бы лучше масштабироваться, но рискует создать слишком много потоков при пиковых нагрузках. Асинхронная модель (NIO с Selector) была бы сложнее для реализации в рамках задания.
Обоснование: Такой подход решает проблему масштабируемости и предотвращает ошибки, такие как разрыв соединений, которые наблюдались ранее.

2. URLEncodedUtils для парсинга Query и форм

Почему: Библиотека Apache HttpClient (URLEncodedUtils) обеспечивает надежный парсинг Query String и данных форм x-www-form-urlencoded, поддерживая кодировку UTF-8 и множественные параметры с одинаковыми именами. Это минимизирует ошибки по сравнению с ручным парсингом.
Альтернативы: Ручной парсинг был бы проще в плане зависимостей, но сложнее в поддержке и тестировании.
Обоснование: Стандартная библиотека упрощает обработку сложных случаев, таких как закодированные символы или нестандартные запросы.

3. Commons FileUpload для multipart

Почему: Обработка multipart/form-data вручную сложна из-за необходимости работы с границами (boundary) и потоками. Библиотека Apache Commons FileUpload абстрагирует эти сложности, поддерживая как загрузку файлов, так и текстовые поля.
Альтернативы: Собственная реализация была бы трудоемкой и подверженной ошибкам.
Обоснование: Выбор библиотеки обеспечивает надежность и соответствие требованиям задания.

4. Дизайн класса Request

Почему: Класс Request инкапсулирует метод, путь, заголовки, тело, параметры Query, параметры форм и части multipart. Использование неизменяемых коллекций (Collections.unmodifiableMap) гарантирует безопасность в многопоточной среде и предотвращает случайные изменения данных.
Альтернативы: Мутабельные коллекции упростили бы код, но увеличили бы риск ошибок.
Обоснование: Такой подход повышает предсказуемость и безопасность работы сервера.

5. Логирование через SLF4J

Почему: SLF4J обеспечивает гибкое логирование, что упрощает отладку запросов и диагностику ошибок, таких как разрыв соединений в предыдущем задании. Простой логгер (slf4j-simple) выбран для учебного проекта.
Альтернативы: Использование System.out было бы проще, но менее гибким. Logback мог бы использоваться в продакшене.
Обоснование: Логирование было добавлено для упрощения отладки, как обсуждалось ранее.

6. Нормализация пути

Почему: Удаление Query String из пути в классе Request упрощает поиск обработчиков, обеспечивая соответствие маршрута /messages для запросов типа /messages?last=10.
Альтернативы: Учет Query String в маршрутизации потребовал бы более сложной логики обработчиков.
Обоснование: Это решает проблему согласованности маршрутов и упрощает логику сервера.

Как запустить

Склонируйте репозитоий:
git clone https://github.com/art4000xxx/http-server-query.git
cd http-server-query


Соберите проект с помощью Maven:
mvn clean package


Запустите сервер:
java -jar target/http-server-query-1.0-SNAPSHOT.jar


Протестируйте сервер с помощью curl:

Query String:curl "http://localhost:9999/messages?last=10&user=john"


x-www-form-urlencoded:curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "name=John&age=30" http://localhost:9999/messages


multipart/form-data:curl -X POST -F "name=John" -F "file=@test.txt" http://localhost:9999/messages





Тестирование
Сервер протестирован с использованием:

PowerShell (Invoke-WebRequest):Invoke-WebRequest -Uri "http://localhost:9999/messages?last=10" -Method GET
Invoke-WebRequest -Uri "http://localhost:9999/messages" -Method POST -ContentType "application/x-www-form-urlencoded" -Body "name=John&age=30"


cURL: Примеры выше.
Браузер: Доступ к http://localhost:9999/messages.

Возможные улучшения

Поддержка маршрутизации на основе параметров Query.
Реализация хранения загруженных файлов на диске.
Расширение обработки ошибок с подробными сообщениями.
Добавление юнит-тестов с использованием JUnit и фреймворков, таких как Javalin.

Автор
art4000xxx (https://github.com/art4000xxx)

Проект выполнен в рамках курса Java от Netology. Приветствуются любые замечания и предложения!
